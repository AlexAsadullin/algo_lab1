# Выводы лабораторной работы

## Анализ производительности алгоритмов на различных датасетах

### Общая оценка для каждого датасета

| Датасет | Лучший алгоритм | Причина |
|---------|-----------------|---------|
| `pair_odd_odd` | Два указателя | Одинаковая четность не требует сложных операций |
| `pair_even_even` | Два указателя | Одинаковая четность не требует сложных операций |
| `pair_even_odd` | Два указателя | Линейная сложность эффективнее других подходов (по сути - случайные данные) |
| `pair_odd_even` | Два указателя | Линейное сканирование оптимально |
| `pair_small_long_big_short` | Бинарный поиск | Бинпоск по огромному массиву эффективнее линейного сканирования |
| `pair_long_small_big_short` | Бинарный поиск | Бинпоск по огромному массиву эффективнее линейного сканирования |
| `pair_intersecting_ranges` | Два указателя | Локальность данных позволяет быстро найти пересечение |
| `pair_no_intersection` | Два указателя | Быстрое определение отсутствия пересечения (в этом суть алгоритма) |
| `pair_identical_values` | Два указателя | Простой случай, проверка на вшивость +- одинаковый результат |
| `pair_single_element` | Два указателя | Простой случай, проверка на вшивость +- одинаковый результат |
| `pair_empty_array` | Два указателя | Граничный случай, проверка на вшивость +- одинаковый результат |
| `pair_extreme_size_difference` | Бинарный поиск | Бинпоск по огромному массиву эффективнее линейного сканирования (в большом 10**6 элементов, в маленьком - незначительное количество) |
| `pair_sequential_overlap` | Два указателя | Нет сильной разницы между алгоритмами |
| `pair_both_empty` | Два указателя | Граничный случай, проверка на вшивость +- одинаковый результат |



## Характеристики каждого алгоритма

### 1. Два указателя (Two Pointers)

**Практическое поведение:**
- **Лучший выбор** на тестах покзаал отличный результат (10 из 14), т.к. данные небольшие, перформит хуже на больших данных (типа pair_small_long_big_short)
- Производительность падает на больших данных
- Отличные результаты на равномерных и пересекающихся диапазонах
- Малый расход памяти
- Слабая сторона: неэффективен при экстремальной разнице размеров массивов

### 2. Бинарный поиск (Binary Search)

**Практическое поведение:**
- **Лучший выбор** - лучше всего показал себя на асимметричных данных (pair_small_long_big_short, pair_intersecting_ranges)
- Стабильная производительность, близкая к экспоненциальному поиску
- Почти идентичная амортизированная память по сравнению с двумя указателями
- Логарифмическая природа спасает при очень больших разницах размеров
- Слабая сторона: неэффективен на маленьких данных

### 3. Экспоненциальный поиск (Exponential Search)

**Практическое поведение:**
- **Лучший выбор** - результат схож с бинпоиском (чуть быстрее в большинстве случаев)
- Экстремальные значения на pair_intersecting_ranges (2000+ единиц памяти) и pair_extreme_size_difference
- Может быть конкурентоспособен на специфических датасетах с локализованными пересечениями
- Теоретически оптимален для данных в контексте M и N, но практически показывает худшие результаты
- Слабые стороны:  Требует больше памяти (рекурсия), неэффективен при больших разбросах
- Требует анализа данных для подбора экспоненциального шага (может стать сильной стороной, если известны закономерности в данных)

### 4. Бинарный поиск с разделением (Binary Divide)

**Практическое поведение:**
- **Лучший выбор** - если нет ограничений по памяти (ее жрет больше всех), самый быстрый в среднем лучае
- Самый стабильный (по скорости) - отсутствует скачок в датасете pair_big_long_small_short 
- Слабости: Разделяй-и-властвуй подход создает дополнительные затраты на стек вызовов

## Итог
Для малых данных - two pointers
Для больших данных где неизвестны пересечения между массивами - binary search
Для больших данных где известны пересечения массивов - exponential search
Для среднего случая - binary divide

При выборе алгоритма следует учитывать описанные выше недостатки, так же сложность и читаемость кода у всех разная (простые решения - 2 указателя и бинпоск, сложнее - экспоненциальный поиск и Бинарный поиск с разделением)