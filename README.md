## Quick Start

скачать данные из облака и поместить в корень директории **/data**
https://disk.360.yandex.ru/d/LPYLKMbkRjNwWw

```bash

pip3 install -r requirements.txt
python3 main.py
```

## Изменения на 18 декабря
- изменен tests.py 150-152, гарантированно разная четность для i-го элемента в n и m, получив массивы с числами разной четности с равномерным распределением чисел одного массива на другой

## Изменения на 17 декабря
- фикс экспоненциального поиска
- добавил charts/worst_case.html - график для худшего случая
- добавил генерацию массива с худшим случаем и запустил тесты на нем (tests.py 148-215); худший случай - все элементы i-й элемент m < i-го элемента n, общий элемент в конце обоих (длина одинаковая)
- множественный запуск реализован в algorithms.py 31-34, 50-53, 69-72, 88-91

## Изменения на 15 декабря
- реализация алгоритмов перемещена из класса Solution (/algorithms.py) в директорию /algorithms_sol (каждый алгоритм в отдельный файл)
- вызов осуществляется по-прежднему из класса Solution, но 1 алгоритм вызывается 1 раз для замера памяти и затем 100 раз для замера скорости (уже память не измеряю чтобы скорость не запороть)
- снова переработал exponential_search - добавил условие обработки if max(arr_m) < min(arr_n): крайний случай, когда у нас не может быть общего элемента

## Изменения на 12 декабря
- Директория **/charts** добавлена в репозиторий, сохранены 2 графика
- Исправлен **exponential_search** на правильную сложность O(Mlog(2N/M))
- Добавлен CONCLUSION.md с выводами и результатами

## Изменения на 8 декабря
- Переработана логика возврата для  two_pointers, binary_search, exponential_search (вернем общий элемент вместо True и -1 вместо False, если общего элемента нет) - требования контеста (binary_divide без изменений)
- Оптимизирована логика binary_search и exponential_search (пожертвовал читаемостью кода, т.к. решения не проходили контест по времени)
- Решения, отправленные в контесте повторяют логику работы класса Solution, но реализованы без ООП, рекурсии, без подсчета времени работы и расхода памяти - т.к. эти оперции дорогие и код не проходит по времени


## Алгоритмы

### 1. Two Pointers (два указателя)
- Использует два указателя для одновременного прохода по обоим массивам
- **Сложность**: O(m + n), где m и n - размеры массивов
- **Память**: O(1) дополнительной памяти
- Эффективен для массивов с похожими элементами

### 2. Binary Search (бинарный поиск)
- Меняет местами массивы так, чтобы искать элементы меньшего массива в большем через `bisect_left`
- **Сложность**: O(m × log n)
- **Память**: O(1) дополнительной памяти
- Хорошо работает когда один массив значительно меньше другого

### 3. Exponential Search (экспоненциальный поиск)
- Сужает пересекающийся диапазон значений бинарными поисками и пробегает его двумя указателями
- **Сложность**: O(m × log n) в худшем случае
- **Память**: O(1) дополнительной памяти
- Эффективен для поиска в больших отсортированных массивах

### 4. Binary Divide (бинарное разделение)
- Рекурсивно делит задачу на подзадачи, используя бинарный поиск для проверки середины
- **Сложность**: O(m × log n)
- **Память**: O(log n) из-за глубины рекурсии
- Разделяет пространство поиска на две части на каждом шаге

`tracemalloc` - для учета расхода памяти.

## Генерация данных

`generate_data.py` содержит функции для генерации тестовых данных различных типов:

### Базовые функции:
- `gen_sorted_random_parity()` - генерирует отсортированный массив с случайными шагами
- `gen_sorted_by_parity()` - генерирует массив только четных или только нечетных чисел

### Тестовые датасеты:
- `pair_odd_odd` / `pair_even_even` - оба массива одного типа четности
- `pair_even_odd` / `pair_odd_even` - массивы разной четности
- `pair_small_long_big_short` / `pair_big_long_small_short` - массивы с разными диапазонами значений
- `pair_intersecting_ranges` - частично пересекающиеся диапазоны
- `pair_no_intersection` - полностью непересекающиеся диапазоны
- `pair_identical_values` - идентичные массивы
- `pair_single_element` / `pair_empty_array` / `pair_both_empty` - граничные случаи
- `pair_extreme_size_difference` - экстремальная разница в размерах
- `pair_sequential_overlap` - смежные диапазоны

Все датасеты сохраняются в папку `data/` в формате `.npy`.

## Тестирование

`tests.py` проводит комплексное тестирование:

1. **Сбор данных**: `collect_performance_data()` запускает все алгоритмы на всех датасетах
2. **Обработка ошибок**: Каждый алгоритм обернут в try/except, ошибки не прерывают тестирование
3. **Визуализация**:
   - `create_performance_chart()` - график времени выполнения (`charts/time.html`)
   - `create_memory_chart()` - график использования памяти (`charts/memory.html`)

### Особенности:
- Логарифмическая шкала для корректного отображения широкого диапазона значений
- Гарантированное отображение точек (минимум 1 байт памяти)
- Цветовое кодирование алгоритмов

Результаты тестирования выводятся в консоль, графики сохраняются в папку `charts/`.

## Структура проекта

```
├── algorithms.py          # Класс Solution с алгоритмами
├── generate_data.py       # Функции генерации тестовых данных
├── tests.py              # Система тестирования и визуализации
├── main.py               # Точка входа (пустой)
├── data/                 # Сгенерированные датасеты (.npy файлы)
├── charts/               # Графики результатов (.html файлы)
└── README.md             # Документация
```
